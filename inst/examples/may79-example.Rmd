GP Example using the May (1979) bistable model
==============================================


Use my custom libraries and the `ggplot` plotting tools

```{r libraries}
require(pdgControl)
require(nonparametricbayes)
require(reshape2)
require(ggplot2)
require(data.table)
library(kernlab)
```

```{r graphing-options, include=FALSE}
opts_knit$set(upload.fun = socialR::notebook.url)
opts_chunk$set(dev.args=list(bg="transparent"), comment=NA, tidy=FALSE)
theme_set(theme_bw())
theme_update(panel.background = element_rect(fill = "transparent",colour = NA),
             plot.background = element_rect(fill = "transparent",colour = NA))
```



```{r}
f <- May
p <- c(r = .75, k = 10, a=1.3, H=1, Q = 3)
K <- 8 # approx
```

Model dynamics look like this:

```{r}
birth <- function(x) p["r"] * (1-  x / p["k"])
death <- function(x) p["a"] * x ^ (p["Q"] - 1) / (x ^ p["Q"] + p["H"])
df <- data.frame(x = x_grid, b = sapply(x_grid, birth), d = sapply(x_grid, death))
ggplot(df) + geom_line(aes(x, b), col = "blue") + geom_line(aes(x,d), col = "red")
````



Noise function, profit function
```{r}
z_g <- function(sigma_g) rlnorm(1, 0, sigma_g) #1+(2*runif(1, 0,  1)-1)*sigma_g #
profit <- profit_harvest(1,0,0)
```


Parameter definitions

```{r}
x_grid = seq(0, 1.5 * K, length=101)
T <- 40
sigma_g <- 0.3
x <- numeric(T)
x[1] <- 1
```



Simulation 

```{r}
x[1] = 2.5
for(t in 1:(T-1))
  x[t+1] = z_g(sigma_g) * f(x[t], h=0, p=p)
plot(x)
```

Predict the function over the target grid

```{r}
obs <- data.frame(x=x[1:(T-1)],y=x[2:T])
X <- x_grid
gp <- gp_fit(obs, X, c(sigma_n=.9, tau = 1., l=.1), "kernlab")

```

Gaussian Process inference from this model

```{r}
df <- data.frame(x=X, y=gp$Ef, ymin=(gp$Ef-2*sqrt(abs(diag(gp$Cf)))), ymax=(gp$Ef+2*sqrt(abs(diag(gp$Cf)))))
true <- data.frame(x=X, y=sapply(X,f, 0, p))
ggplot(df)  + geom_ribbon(aes(x,y,ymin=ymin,ymax=ymax), fill="gray80") +
  geom_line(aes(x,y)) + geom_point(data=obs, aes(x,y)) +
  geom_line(data=true, aes(x,y), col='red', lty=2)
```



## Stochastic Dynamic programming solution based on the posterior Gaussian process:

```{r}
h_grid <- x_grid
```

GP Solution

```{r}
matrices_gp <- gp_transition_matrix(gp)
opt_gp <- find_dp_optim(matrices_gp, x_grid, h_grid, 20, 0, profit, delta=.01)
```

Optimal solution

```{r}
matrices_true <- f_transition_matrix(f, p, x_grid, h_grid, sigma_g)
opt_true <- find_dp_optim(matrices_true, x_grid, h_grid, 20, 0, profit, delta=.01)
```

Optimal parametric solution in which a parameter is estimated with error

```{r}
matrices_estimated <- f_transition_matrix(f, p, x_grid, h_grid, sigma_g=0.01)
opt_estimated <- find_dp_optim(matrices_estimated, x_grid, h_grid, 20, 0, profit, delta=.01)
```


```{r policy_plot}
policies <- melt(data.frame(stock=x_grid, 
                            GP = x_grid[opt_gp$D[,1]], 
                            Exact = x_grid[opt_true$D[,1]],
                            Approx = x_grid[opt_estimated$D[,1]]),
                  id="stock")

policy_plot <- ggplot(policies, aes(stock, stock - value, color=variable)) +
  geom_point() + xlab("stock size") + ylab("escapement") 
policy_plot
```

We can see what happens when we attempt to manage a stock using this:

``` {r othernoise}
z_g <- function() rlnorm(1,0, sigma_g)
````

``` {r  simulate }
set.seed(1)
sim_gp <- ForwardSimulate(f, p, x_grid, h_grid, K, opt_gp$D, z_g, profit=profit)
set.seed(1)
sim_true <- ForwardSimulate(f, p, x_grid, h_grid, K, opt_true$D, z_g, profit=profit)
set.seed(1)
sim_est <- ForwardSimulate(f, p, x_grid, h_grid, K, opt_estimated$D, z_g, profit=profit)
````


```{r}
dat <- list(est = sim_est, gp = sim_gp, true = sim_true)
dat <- melt(dat, id=names(dat[[1]]))
dt <- data.table(dat)
setnames(dt, "L1", "method") 
```

``` {r  simplot}
ggplot(dt) + geom_line(aes(time,fishstock, color=method))
ggplot(dt) + geom_line(aes(time,harvest, color=method))
````

Total Profits

```{r}
c( gp = sum(sim_gp$profit), true = sum(sim_true$profit), est = sum(sim_est$profit))
```

