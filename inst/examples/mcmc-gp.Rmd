

``` {r libs, include=FALSE}
rm(list=ls())   
require(nonparametricbayes)
require(reshape2)
require(ggplot2)
require(data.table)
require(tgp)
```

```{r graphing-options, include=FALSE}
opts_knit$set(upload.fun = socialR::notebook.url)
opts_chunk$set(dev.args=list(bg="transparent"), tidy=FALSE, comment=NA)
theme_notebook <- theme_grey() + 
                  theme(plot.background = element_rect(fill = "transparent",colour = NA),
                        panel.grid.minor=element_line(colour="transparent"))
theme_set(theme_notebook)
```


```{r results="hide"}
knit("~/Documents/code/nonparametric-bayes/inst/examples/beverton_holt_data.Rmd")
true <- data.frame(x = x_grid, y = sapply(x_grid, f, 0, p))
XX <- as.matrix(x_grid)
X <- as.matrix(obs$x)
Z <- as.matrix(obs$y)
```

Normalize data to the unit (hyper)cube.  

```{r, include=FALSE, eval=FALSE}
unit_norm <- function(x, M=NULL, m=NULL, invert=FALSE){
  if(is.null(M)){
    M <- max(x) 
    m <- min(x)
    message(paste("Max M = ", M, "min m = ", m))
  }
  
  if(!invert) {
    (x-m)/(M-m)
  } else {
    (M-m)*x+m
  }
}
XX = unit_norm(XX)
X = unit_norm(X)
Z = unit_norm(Y)
```




```{r}
gp <- bgp(X=X, XX=XX, Z=Z, meanfn="constant", bprior="b0", BTE=c(1000,6000,2), m0r1=FALSE, verb=4, corr="exp", trace=TRUE, s2.p=c(5,10), tau2.p=c(5,10), s2.lam="fixed", tau2.lam="fixed")
```






Take a look at the trace

```{r}
names(gp$trace$XX[[1]])
dim(gp$trace$XX[[1]])
gp$trace$XX[[1]][1,]
gp$trace$XX[[1]][2500,]
````

* `index` is the sampling point (from `BTE`, we see we sample starting at step 1000 and ending at step 6000, recording every 2 steps, so there are $(T-B)/E = 2500$ index points).  

* `lambda`
* `s2`
* `tau2`
* `beta0`
* `nug`
* `d`

Extract the posterior Gaussian process mean and the $\pm 2$ standard deviations over the predicted grid from the fit:

```{r}

dat <- data.frame(x    = gp$XX[[1]], 
                 y    = gp$ZZ.km, 
                 ymin = gp$ZZ.km - 1.96 * sqrt(gp$ZZ.ks2), 
                 ymax = gp$ZZ.km + 1.96 * sqrt(gp$ZZ.ks2))


```

Plot the posterior Gaussian Process:

```{r gp-plot}
  p1 <- ggplot(dat) +
    geom_ribbon(aes(x=x,y=y, ymin=ymin, ymax=ymax), fill="grey80") + # Var
    geom_line(aes(x=x,y=y), size=1) + #MEAN
    geom_point(data=gp$obs,aes(x=x,y=y)) + 
    labs(title=paste("llik =", prettyNum(gp$llik)))
  if(!is.null(true))
    p1 <- p1 + geom_line(data = true, aes(x, y), col = "red", lty = 2) 
p1 + theme_notebook
```




is mean ZZ.mean or ZZ.km?  is the var I want ZZ.s2 or ZZ.ks2?)  I want the kreiging values (km, ks2).  The others slightly don't agree with the above.  We do this by comparing to the plotted option (which handles the rescaling(?) from `choose.center` first).


```{r}
center <- tgp:::tgp.choose.center(gp, "mean")
Z.mean <- center$Z
X_vals <- center$X[, 1]
o <- order(X_vals)
Zb.q1 <- Z.mean + 1.96 * sqrt(c(gp$Zp.ks2, gp$ZZ.ks2))
Zb.q2 <- Z.mean - 1.96 * sqrt(c(gp$Zp.ks2, gp$ZZ.ks2))
V <- c(gp$Zp.ks2, gp$ZZ.ks2)[o]
df <- data.frame(x=X_vals[o], y=Z.mean[o], ymin=Zb.q1[o], ymax=Zb.q2[o])



raw <- data.frame(x    = gp$XX[[1]], 
                 y    = gp$ZZ.mean, 
                 ymin = gp$ZZ.mean - 1.96 * sqrt(gp$ZZ.s2), 
                 ymax = gp$ZZ.mean + 1.96 * sqrt(gp$ZZ.s2))


p1 + geom_ribbon(aes(x,y, ymin=ymin, ymax=ymax), fill="red", alpha=.1, data=df) + geom_line(aes(x,y), col="red", data=df)  + geom_ribbon(aes(x,y, ymin=ymin, ymax=ymax), fill="blue", alpha=.1, data=raw) + geom_line(aes(x,y), col="blue", data=raw) 
```


Find the actual optimum policy from the true parametric model

```{r}
x_grid <- dat$x
h_grid <- x_grid
matrices_true <- f_transition_matrix(f, p, x_grid, h_grid)
opt_true <- find_dp_optim(matrices_true, x_grid, h_grid, 20, 0, profit, delta=.01)
```


Estimate a policy from the Gaussian Process:

```{r}
rownorm <- function(M) t(apply(M, 1, function(x) x/sum(x)))
matrices_gp <- lapply(h_grid, function(h){
    S <- dat$y - h
    F_ <- t(sapply(1:length(S), function(i){
      if(S[i]>0) {
        out <- dlnorm(x_grid/S[i], 0, V[i])
      } else {
        out <- numeric(length(x_grid))
        out[1] <- 1
        out
      }
    }))
    F_ <- rownorm(F_)
  })
opt_gp <- find_dp_optim(matrices_gp, x_grid, h_grid, 20, 0, profit, delta=.01)
```


```{r}
matrices_true[[1]][1:10,1:10]
matrices_gp[[1]][1:10,1:10]

```


```{r policy_plot}
policies <- melt(data.frame(stock=x_grid, GP = x_grid[opt_gp$D[,1]], Exact = x_grid[opt_true$D[,1]]), id="stock")
policy_plot <- ggplot(policies, aes(stock, stock - value, color=variable)) +
  geom_point() + xlab("stock size") + ylab("escapement") 
policy_plot + theme_notebook
```

We can see what happens when we attempt to manage a stock using this:

``` {r othernoise}
z_g <- function() rlnorm(1,0, sigma_g)
````

``` {r  simulate }
set.seed(1)
sim_gp <- ForwardSimulate(f, p, x_grid, h_grid, K, opt_gp$D, z_g, profit=profit)
set.seed(1)
sim_true <- ForwardSimulate(f, p, x_grid, h_grid, K, opt_true$D, z_g, profit=profit)
````

``` {r  simplot}
df <- data.frame(time = sim_gp$time, stock_gp = sim_gp$fishstock, stock_true = sim_true$fishstock, harvest_gp = sim_gp$harvest, havest_true = sim_true$harvest)
df <- melt(df, id="time")
simplot <- ggplot(df) + geom_line(aes(time,value, color=variable))
simplot + theme_notebook
````

Total Profits

```{r}
sum(sim_gp$profit)
sum(sim_true$profit)
```




